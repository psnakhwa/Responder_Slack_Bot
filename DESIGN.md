# Design Document

## Problem statement
What is the problem?
Nowadays, a major concern for all the managers in any software company is to find the people to work on new as well as existing issues in a project. It is also an extremely tedious task for the manager to manually ensure that all the employees are not just assigned to an issue but are also working on the issues which are the best possible assignment for them as per their potential. Under utilization (inefficient resource allocation) of an employee’s potential can be considered as a wastage of critical company resources. Secondly, when an employee is assigned to work on an existing issue he/she needs an understanding of the code and associated errors previously worked upon by another team member which becomes tough for him to identify. A solution for this will quickly ensure peer-mapping and reduce effort to understand the code. Thirdly, it is hard to find the right developer who can review the code written by other employees. Code review is critical to maintain the standard of code that goes in production. So, to find the right person for a particular task is a major challenge that needs to be addressed as effectively as possible.

Why is this a problem? 
Currently, the managers find assignees for issues manually by checking individual calendars and skills. Also, there is no standard procedure to find the code reviewer. Finding people is a task for the manager which needs to be done repeatedly. The time manager spends on this repetitive task of allocating and mapping people to issues and deliverables is a wastage of the manager’s precious time as well as crucial company resources. So, it is better for the company that it’s manager spends the least possible time on these tasks. There are few factors which contributes to the choice of assignees: 
Who is experienced in working with these kinds of issues?
What skill set does the employee possess?
Who has the capability to review the code?
As this assignment involves certain factors which has to be considered every single time an issue needs to be assigned, this process has to be automated in an efficient way to assist the manager in mapping assignees to issues.

## Bot Description
The Traži Bot would be a great solution for all the problems we mentioned above. It’s main aim would be to find appropriate assignees for various issues as well as code reviews and recommend them to the manager and thus reduce manager’s workload.

The bot will have the following workflows:

Manager asks for all issues → Bot provides a list →  Manager provides a particular issue name → Bot uses text mining to extract the critical information from the issue name and maps it with commit history of all the developers to  recommend the best possible assignee for that issue → Bot provides a list of best possible assignees to the manager. → Manager selects one name from that list → Bot assigns the issue to that developer and notifies him accordingly.

Developer provides a filename → Bot provides a list of employees who made modifications on that file in the past → Developer instructs the bot to notify those employees → Bot notifies the employees.

Developer provides a filename to the Bot and asks for potential reviewers  → Bot provides a list of potential reviewers → Developer selects the reviewer which he/she wants → Bot notifies those reviewers.

These workflows will save the manager’s time and improve productivity of the team. The Bot will have conversation with the manager as well as the developers and will notify them of all the important events. Traži Bot would best fit into the Responder bot category since it will respond to an event created by the manager and then make api calls to fetch data, process it and provide its response. The Bot will follow a Reactor design pattern as it will respond to the events generated by the manager. The Bot can be considered as a combination of a Chatbot and a Code Drone as it will have a conversation with the manager and perform repetitive programming tasks in an autonomous manner. It will only need manager input to confirm the assignment.

## Use Cases

```
Use Case 1: Finding an employee for a new issue based on his/her skill set and deadline of issues they are currently working on
1 Preconditions:
  Manager must have Slack and github tokens on the system. Manager must know the issue number for which an employee needs to be find.
2 Main Flow:
  A manager requests for a list of employees that can best solve a particular open issue. Bot will return a list which will contain the the employees ordered on the basis of their skill set and the deadline of the issues they are currently working on. Manager selects an employee, the bot assigns the issue to that employee.
3 Subflows:
[S1] Manager requests for a list of employees to solve an issue.
[S2] Bot returns a list of employees most appropriate to solve that issue. Manager selects an employee.
[S3] Bot assigns the issue to the selected employee.
4 Alternative Flows
 [E1] Issue does not exist.
 [E2] Issue already in closed state.

```
```
Use Case 2: Finding major contributor who is responsible for past modifications in the code 
1 Preconditions
  Employee must have Slack and github tokens on the system. Employee must know the filename where more modifications are needed.
2 Main Flow
  Employee provides the filename of the code requiring modifications. Bot returns contributor’s username who made major commits to that file previously. Employee asks bot to notify the contributor(concerned employee) about the same.
3 Subflows
[S1] Employer provides filename of code requiring modifications
[S2] Return major contributor of that code.
[S3] That contributor is notified about requiring modifications.
4 Alternative Flows
[E1] No such file exists in the repository.

```
```
Use Case 3: Finding a code reviewer for an issue.
1 Preconditions
  Manager must have Slack and github tokens on the system.
2 Main Flow
  A manager or an employee requests for a list of most suitable reviewers for a new commit. Bot finds the employees based on their previous experience on reviewing similar issues and the number of commits they have previously made which further shows  they can be good reviewers. 
3 Subflows
[S1] An employee requests for a list of suitable reviewers for a recent commit.
[S2] Bot returns a list of employees who can best review the code.
[S3] The employee selects all the employees from that list for reviewing the commit.
[S4] Bot notifies those employees who have been selected for the review.
4 Alternative Flows
[E1] Issue does not exist.

```
## Design Sketches
### Wireframe
This wireframe shows the interaction between Manager and Bot in a Slack GUI. This interaction covers all 3 use cases mentioned above : </br>
<img src="/images/wireframe_design.PNG"/>


### Storyboard

**case 1: Recommend an assignee for a new github issue to a manager based on employee’s skill set**     
  
  
<img src="/images/Storyboard/case1.PNG" height="375" width="600"/>  
  
**case 2: Providing the Employee with a list of major contributors for a set of code**   
  
<img src="/images/Storyboard/usecase2.PNG" height="375" width="600"/>  

**case 3: Provide list of reviewers required to review a set of code**   
  
 <img src="/images/Storyboard/usecase3.PNG" height="375" width="600"/>

## Architecture Design
Architecture best represents a repository architecture pattern, in which the data for all the issues, every developer's’ past issue work and commit history are being pulled more often than pushed (like creating and assigning an issue) to Github. 

The users will use slack(Bot UI) as an interface to communicate with the bot, which will process the commands given by user and will get all the required data from github and provide user the output in a predefined format and may notify users based on the requirement. Node.js will be used as a backend with third-party libraries. 

<img src="/images/arch.jpg"/>

We will use Github REST api as an API gateway between bot and Github. Our project repository will be saved on the github. When bot receives a command, it (Node.js script) will call REST apis to request a required information (eg. people who can solve an issue, people who can be responsible for a bug, list of issues within deadline). As per the command bot will run an algorithm to find the right set of people to solve an issue (using issue heading, description, user's commit history, and labels) or an algorithm to find people who might be responsible for introducing or fixing a particular bug (may be using git blame and other ways). Through this bot will try to find a best possible matches.

AWS EC2 instance will have our bot deployed. This is the component where all the parsing, analysis and processing will be done. Bot will parse a command given by user to determine what action it is supposed to execute. These actions may involve pulling required data from github or pushing changes to modify issues (eg. add or change assignee, create an issue)


**Component Diagram**     
  
  
<img src="/images/component.PNG" height="375" width="550"/>  

## Additional Patterns
* We will require a mixture of patterns in order to make the Bot work efficiently and accurately. 
* Two main patterns that we are going to use are Adapter and Singleton Design pattern and these are the most used design patterns used for bit design. 

* Our bot will act as an Adapter between Manager and GitHub issues. The manager will give certain commands to the Bot and the Bot will make the changes accordingly in the GitHub issues thus acting as a mediator.

* Second pattern that we are going to use is Singleton design pattern.  As we know Singleton: defines an instance operation that lets clients access its unique interface and clients access a Singleton instance solely through Singleton’s Instance operation.
* Obviously we cannot have more than one instance of a bot as we want to avoid race condition of multiple bots working on same command from the manager. So one client --> one interface --> one bot. Client here is not individual users, infact we can say client is “one channel with a group of managers”.

